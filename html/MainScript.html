
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>MainScript</title><meta name="generator" content="MATLAB 8.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-07-25"><meta name="DC.source" content="MainScript.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">Initialise</a></li><li><a href="#3">Options</a></li><li><a href="#4">Assign options</a></li><li><a href="#5">Experimental data</a></li><li><a href="#6">Parameters and Inputs</a></li><li><a href="#7">Assign identified parameters</a></li><li><a href="#8">Load EIS polyfits</a></li><li><a href="#9">Spectral-galerkin model</a></li><li><a href="#10">Simulate</a></li><li><a href="#11">Plot 0: Polyfit of impedance</a></li><li><a href="#12">Plot 1: Measured vs predicted temperatures</a></li><li><a href="#13">Plot 2: Radial temperature distribution at selected times</a></li><li><a href="#14">Plot 3: 2-D Temperature Contour Plot at selected time</a></li><li><a href="#15">Error analysis 1: RMSE values</a></li><li><a href="#16">Error analysis 2: Histogram of errors</a></li></ul></div><pre class="codeinput"><span class="comment">%-------------------------------------------------------------------------%</span>
<span class="comment">%              2-D EKF Impedance-Temperature State-Estimator              %</span>
<span class="comment">%-------------------------------------------------------------------------%</span>

<span class="comment">%{
</span><span class="comment">My name is Robert Richardson (robert.richardson@eng.ox.ac.uk) and I hold
</span><span class="comment">the MIT license for this code. An accompanying paper for this code is:
</span><span class="comment">% Robert R. Richardson, Shi Zhao, David A. Howey, On-board monitoring of
</span><span class="comment">% 2-D spatially-resolved temperatures in cylindrical lithium-ion batteries:
</span><span class="comment">% Part I. Low-order thermal modelling, Journal of Power Sources, Vol 326,
</span><span class="comment">% 2016, Pages 377-388, http://dx.doi.org/10.1016/j.jpowsour.2016.06.103.
</span><span class="comment">
</span><span class="comment">I would ask that you cite this paper if you want to use this code for
</span><span class="comment">your own research. For further details on the work of the Energy Power
</span><span class="comment">Group at Oxford, please see epg.eng.ox.ac.uk.
</span><span class="comment">%}
</span>
<span class="comment">% This code implements a Chebyshev Spectral Galerkin 2D thermal model and</span>
<span class="comment">% an Extended Kalman Filter using electrochemical impedance measurement</span>
<span class="comment">% input.</span>

<span class="comment">% Guide to structures used:</span>
<span class="comment">% 'p':          stores [p]arameters and inputs (common to both models)</span>
<span class="comment">% 'sg':         stores [s]pectral-[G]alerkin model inputs/outputs</span>
<span class="comment">% 'kf':         stores [K]alman [f]iltered model inputs/outputs</span>
<span class="comment">% 'ekf':        stores [E]xtended [K]alman [f]iltered model inputs/outputs</span>
<span class="comment">% 'mult':       stores outputs at [mult]iple instances (for both models)</span>
</pre><h2>Initialise<a name="2"></a></h2><pre class="codeinput">clear; close <span class="string">all</span>; clc;
addpath(genpath(<span class="string">'./Functions'</span>));
addpath(genpath(<span class="string">'./Data'</span>));
pl = abbreviations();   <span class="comment">% struct of abbreviations for commonly used strings</span>
set(0,<span class="string">'defaultaxeslinewidth'</span>,1.0)                    <span class="comment">% plotting preferences</span>
set(0,<span class="string">'defaultlinelinewidth'</span>,1.4)
FS = 10;   <span class="comment">% fontsize</span>
</pre><h2>Options<a name="3"></a></h2><p>Below are some options for the user to play around with.</p><pre class="codeinput">sel_exp = 4;             <span class="comment">% select exp. (1,2)=uninsulated; (3,4)=insulated</span>
sel_eis = 4;             <span class="comment">% select EIS fit (4=HEV-II; ensures only interp.)</span>
sel_error = true;     	 <span class="comment">% initialise with error? (otherwise plots EIS fit)</span>
sel_thermocouple = 3;  	 <span class="comment">% select thermocouple measurement for linear KF</span>
                      	 <span class="comment">% T_1 (core), T_2 (surf left), T_3 (surf mid),</span>
                         <span class="comment">% T_4 (surf right).</span>
plot_times = [150,800];  <span class="comment">% choose times (sec) at which to plot radial dist.</span>
</pre><h2>Assign options<a name="4"></a></h2><pre class="codeinput">exp_info = cell(1,2);
<span class="keyword">switch</span> sel_exp                                           <span class="comment">% drive cycle info</span>
    <span class="keyword">case</span> {2,3,4}; exp_info{1} = <span class="string">'HEV-I'</span>;
    <span class="keyword">case</span> {1}; exp_info{1} = <span class="string">'HEV-II'</span>;
<span class="keyword">end</span>
<span class="keyword">switch</span> sel_exp                       <span class="comment">% configuration: insulated/uninsulated</span>
    <span class="keyword">case</span> {1,2}; exp_info{2} = <span class="string">'Uninsulated'</span>;
    <span class="keyword">case</span> {3,4}; exp_info{2} = <span class="string">'Insulated'</span>;
<span class="keyword">end</span>
str_info = strcat(exp_info{1},<span class="string">' ('</span>, exp_info{2},<span class="string">')'</span>);
</pre><h2>Experimental data<a name="5"></a></h2><p>Load experimental data, struct 'exp', containing current, voltage, temperatures and impedance.</p><pre class="codeinput"><span class="keyword">switch</span> sel_exp
    <span class="keyword">case</span> 1; load(<span class="string">'Data_Uninsulated_1'</span>);
    <span class="keyword">case</span> 2; load(<span class="string">'Data_Uninsulated_2'</span>);
    <span class="keyword">case</span> 3; load(<span class="string">'Data_Insulated_1'</span>);
    <span class="keyword">case</span> 4; load(<span class="string">'Data_Insulated_2'</span>);
<span class="keyword">end</span>
exp.Tz1 = -ones(size(exp.t));           <span class="comment">% no measurements at right centre</span>
exp.Tz2 = -ones(size(exp.t));           <span class="comment">% no measurements at left centre</span>
</pre><h2>Parameters and Inputs<a name="6"></a></h2><pre class="codeinput">p = func_parameters();   	  <span class="comment">% assign struct 'p' of known model parameters</span>
p = func_inputs_exp(p,exp);   <span class="comment">% assign model inputs to 'p'</span>
</pre><h2>Assign identified parameters<a name="7"></a></h2><p>Assign parameters, k_z, h_r, h_l, h_t and h_b, from parameter identification experiments.</p><pre class="codeinput"><span class="comment">% Use identified parameters from either experiment for each configuration.</span>
<span class="comment">% Loaded data consists of struct 'id' containing fields of parameters.</span>
<span class="keyword">switch</span> sel_exp
    <span class="keyword">case</span> {1,2}; load(<span class="string">'Identified_Parameters_Uninsulated_2'</span>);         <span class="comment">% or 1</span>
    <span class="keyword">case</span> {3,4}; load(<span class="string">'Identified_Parameters_Insulated_2'</span>);           <span class="comment">% or 1</span>
<span class="keyword">end</span>

<span class="comment">% Assign identified parameters to struct 'p'</span>
p.kz = id.kz;                       <span class="comment">% axial thermal conductivity</span>
p.hr = id.hr; p.hl = 0;             <span class="comment">% left/right convection coefficient</span>
p.hb = id.hb; p.ht = id.ht;         <span class="comment">% top/bottom convection coefficient</span>

<span class="comment">% Display parameters</span>
fprintf(char(strcat(<span class="keyword">...</span>
    <span class="string">'Parameters from'</span>,{<span class="string">' '</span>},exp_info{2}, <span class="string">' configuration.\n'</span>)));
fprintf(<span class="string">'cp\t\t kr\t\t kz\n%.0f \t %.3f \t %.2f \n'</span>, p.cp,p.kr,p.kz)
fprintf(<span class="string">'hr\t\t hb\t\t ht\n%.1f \t %.1f \t %.1f \n\n'</span>,<span class="keyword">...</span>
    p.hr,p.hb,p.ht)
</pre><pre class="codeoutput">Parameters from Insulated configuration.
cp		 kr		 kz
910 	 0.350 	 19.00 
hr		 hb		 ht
16.9 	 23.3 	 154.9 

</pre><h2>Load EIS polyfits<a name="8"></a></h2><p>Load EIS data. Data consists of struct 'pol' containing the polyfit of impedance-temperature data.</p><pre class="codeinput"><span class="keyword">switch</span> sel_eis
    <span class="keyword">case</span> 1; load(<span class="string">'Identified_EIS_Uninsulated_1'</span>,<span class="string">'pol'</span>);
    <span class="keyword">case</span> 2; load(<span class="string">'Identified_EIS_Uninsulated_2'</span>,<span class="string">'pol'</span>);
    <span class="keyword">case</span> 3; load(<span class="string">'Identified_EIS_Insulated_1'</span>,<span class="string">'pol'</span>);
    <span class="keyword">case</span> 4; load(<span class="string">'Identified_EIS_Insulated_2'</span>,<span class="string">'pol'</span>);
<span class="keyword">end</span>
<span class="comment">% load('./Data/Identified_EIS','pol');</span>
</pre><h2>Spectral-galerkin model<a name="9"></a></h2><pre class="codeinput">sg.N = 2;                        <span class="comment">% no. of basis functions in each direction</span>
sg.Ns = sg.N^2;                                       <span class="comment">% total no. of states</span>
[sg.A,sg.B,sg.C,sg.E,sg.rr,sg.zz,sg.Psi,sg.Te,sg.ye] = <span class="keyword">...</span>
    func_spectral_galerkin(p, sg.N);          	 <span class="comment">% calculate state matrices</span>

<span class="comment">% Prepare simulation</span>
sg.t_step = 1;
sg.A_d = expm((sg.E\sg.A)*sg.t_step);
sg.B_d = (sg.E\sg.A)\((sg.A_d-eye(size(sg.A_d)))*(sg.E\sg.B));

<span class="comment">% Initialise states, inputs and outputs</span>
sg.x = zeros(length(p.t),length(sg.A));                            <span class="comment">% states</span>
<span class="keyword">switch</span> sel_error                             <span class="comment">% initialise with error or not</span>
    <span class="keyword">case</span> 0; sg.x(1,:) = [7.3464 -0.0253 -0.0614 -0.3167];  	<span class="comment">% correct inits</span>
    <span class="keyword">case</span> 1; sg.x(1,:) = [22.2855 1.98354 4.56853 0.305134];    <span class="comment">% with error</span>
<span class="keyword">end</span>
sg.u = zeros(size(sg.B,2),length(p.t));                            <span class="comment">% inputs</span>
sg.y = zeros(length(p.t),size(sg.C,1));                           <span class="comment">% outputs</span>
</pre><h2>Simulate<a name="10"></a></h2><p>Initialise models</p><pre class="codeinput">ol = sg;                         <span class="comment">% open-loop model (copy spectral galerkin)</span>
kf = func_init_kf(sg, 5e-3, 0.3, 1);                 <span class="comment">% linear kalman filter</span>
ekf = func_init_kf(sg, 5e-3, 3e-5, 1); 	  <span class="comment">% extended kalman filter (with Z)</span>
sel_meas = <span class="keyword">...</span><span class="comment">     % assign selected thermocouple measurement for linear KF</span>
    func_thermocouple2measurement(sel_thermocouple);

<span class="comment">% Loop over time steps</span>
<span class="keyword">for</span> i = 1:length(p.t)-1
    ui = [p.Q(i)/p.Vb; 1];                                        <span class="comment">% input i</span>
    meas_vec = [-1,-1,exp.Tr1(i),exp.Tr2(i),<span class="keyword">...</span>
        exp.Tr2z2(i), exp.Tr2z1(i)];      <span class="comment">% vector of all measurements at i</span>
    sg = func_predict(sg,i,ui);                         <span class="comment">% open-loop predict</span>
    kf = func_predict(kf,i,ui);                                <span class="comment">% KF predict</span>
    kf = func_measure(kf,i,meas_vec,sel_meas);                 <span class="comment">% KF measure</span>
    ekf = func_predict(ekf,i,ui);                             <span class="comment">% EKF predict</span>
    Zm = exp.Im(i);
    <span class="keyword">if</span> Zm~=-1; ekf = func_measure_nl(ekf,i,Zm,pol.p); <span class="keyword">end</span>     <span class="comment">% EKF measure</span>
<span class="keyword">end</span>

<span class="comment">% Rename outputs as something more intuitive</span>
sg = func_rename_outputs(sg);
kf = func_rename_outputs(kf);
ekf = func_rename_outputs(ekf);
ekf.Im = ekf.Zp;
</pre><h2>Plot 0: Polyfit of impedance<a name="11"></a></h2><pre class="codeinput">plot_eis = ~sel_error;    <span class="comment">% plot EIS fit (if running with no initial error)</span>
<span class="keyword">if</span> plot_eis == 1;
    pol.T = sg.Tm(exp.tm)';
    pol.Z = exp.Im(exp.tm);
    ids = [];
    <span class="keyword">for</span> i = 2:length(pol.T)                  <span class="comment">% enforce monotonic increasing</span>
        <span class="keyword">if</span> pol.T(i)&lt;pol.T(i-1); ids = [ids,i]; <span class="keyword">end</span>
    <span class="keyword">end</span>
    pol.T = pol.T(ids); pol.Z = pol.Z(ids);
    pol.Tnew = min(pol.T):0.1:max(pol.T);
    pol.Znew = interp1(pol.T,pol.Z,pol.Tnew);
    pol.T = pol.Tnew; pol.Z = pol.Znew;

    <span class="comment">% Polyfit</span>
    pol.p = polyfit(pol.T,pol.Z,2);
    pol.Tcont = linspace(min(pol.T)-1, max(pol.T)+1);
    pol.Zcont = polyval(pol.p,pol.Tcont);

    <span class="comment">% Plot</span>
    figure(<span class="string">'position'</span>,[700 100 400 300]); hold <span class="string">on</span>;
    plot(pol.T,pol.Z,<span class="string">'o'</span>,<span class="string">'markersize'</span>,5,<span class="string">'color'</span>,pl.b)
    plot(pol.Tcont,pol.Zcont,<span class="string">'linewidth'</span>,1.6,<span class="string">'color'</span>,pl.r)
    xlim([pol.Tcont(1),pol.Tcont(end)])
    xlabel(<span class="string">'Temperature (\circ C)'</span>)
    ylabel(<span class="string">'Im(Z) (\Omega)'</span>)
    legend(<span class="string">'Data'</span>,<span class="string">'Polynomial fit'</span>)
    tightfig();
<span class="keyword">end</span>
</pre><h2>Plot 1: Measured vs predicted temperatures<a name="12"></a></h2><p>(a) Temperature profiles: T(top, centre) and T(bottom, centre) vs. time (b) Heat generation profile: Q vs. t</p><pre class="codeinput">figure(<span class="string">'position'</span>,[100 100 700 420])

<span class="comment">% --------------- Plot (a): Temperature Evolution --------------- %</span>
hax(1) = subplot(4,1,1:3); hold <span class="string">on</span>;
ha = plot(exp.t,exp.Tenv, <span class="string">'k-'</span>, <span class="string">'linewidth'</span>,1);                       <span class="comment">% air</span>

<span class="comment">% Experimental</span>
hEXP = plot(exp.t,exp.Tr1,<span class="string">'-'</span>,<span class="string">'color'</span>,[.3 .3 .3],<span class="string">'markersize'</span>,5);
plot(exp.t,exp.Tr2z2,<span class="string">'-'</span>,<span class="string">'color'</span>,[.3 .3 .3],<span class="string">'markersize'</span>,5);
plot(exp.t,exp.Tr2,<span class="string">'-'</span>,<span class="string">'color'</span>,[.3 .3 .3],<span class="string">'markersize'</span>,5);

<span class="comment">% Open-loop</span>
hSG = plot(p.t,sg.Tr1,<span class="string">'color'</span>,pl.b);
plot(p.t,sg.Tr2, <span class="string">'color'</span>,pl.b);
plot(p.t,sg.Tr2z2, <span class="string">'color'</span>,pl.b);

<span class="comment">% Kalman Filter (with T_3)</span>
plot(p.t,kf.Tr2z2,     <span class="string">'color'</span>,pl.g,<span class="string">'linestyle'</span>,<span class="string">'--'</span>);
plot(p.t,kf.Tr2,     <span class="string">'color'</span>,pl.g,<span class="string">'linestyle'</span>,<span class="string">'--'</span>);
hKF1 = plot(p.t,kf.Tr1,     <span class="string">'color'</span>,pl.g,<span class="string">'linestyle'</span>,<span class="string">'--'</span>);
<span class="comment">% plot(p.t,f1.Tm,'color',fl.g,'linestyle','--');                     % mean</span>

<span class="comment">% Extended Kalman Filter (with Z)</span>
plot(p.t,ekf.Tr2z2,<span class="string">'color'</span>,pl.r,<span class="string">'linestyle'</span>,<span class="string">'-.'</span>);
plot(p.t,ekf.Tr2,<span class="string">'color'</span>,pl.r,<span class="string">'linestyle'</span>,<span class="string">'-.'</span>);
hKF_nl = plot(p.t,ekf.Tr1,<span class="string">'color'</span>,pl.r,<span class="string">'linestyle'</span>,<span class="string">'-.'</span>);

<span class="comment">% Axis limits/labels/legend</span>
xmax = 2600;
xlim([0 xmax]);
ylims = get(gca,<span class="string">'ylim'</span>);
set(gca,<span class="string">'xticklabel'</span>,[]);
ylabel(<span class="string">'Temperature (\circC)'</span>);
set(gca,<span class="string">'fontsize'</span>,FS);
hleg(1) = legend([hEXP hSG hKF1 hKF_nl ha],<span class="keyword">...</span>
    <span class="string">'Experimental'</span>,<span class="string">'Open-loop'</span>,<span class="string">'KF with T_s'</span>,<span class="string">'EKF with Z'''''</span>,<span class="string">'Air'</span>,<span class="keyword">...</span>
    <span class="string">'location'</span>,<span class="string">'best'</span>);

<span class="comment">% Plot tframes line</span>
tframes = [plot_times,xmax];
plot([tframes(1), tframes(1)],[ylims(1), ylims(2)],<span class="string">'k-.'</span>,<span class="string">'linewidth'</span>,1)
text(xmax*0.03,ylims(2)*0.98,str_info,<span class="keyword">...</span>
    <span class="string">'fontsize'</span>,FS,<span class="string">'verticalalignment'</span>,<span class="string">'top'</span>,<span class="string">'horizontalalignment'</span>,<span class="string">'left'</span>)


<span class="comment">% --------------- Plot (b): Impedance Profile --------------- %</span>
hax(2) = subplot(4,1,4); hold <span class="string">on</span>;
plot(exp.tm, 1e3*exp.Im(exp.tm),<span class="string">'-'</span>,<span class="string">'color'</span>,[.3 .3 .3]);
plot(exp.tm, 1e3*ekf.Im(exp.tm),<span class="string">'-.'</span>);
xlim([0 xmax]);
ylabel(<span class="string">'Z'''' (m\Omega)'</span>);
xlabel(<span class="string">'Time (s)'</span>);
hleg(2) = legend(<span class="string">'Experimental'</span>,<span class="string">'EKF with Z'''''</span>);
set(gca,<span class="string">'fontsize'</span>,FS)


<span class="comment">% ------ Post-process ------ %</span>
linkaxes([hax(1), hax(2)],<span class="string">'x'</span>);                         <span class="comment">% link axes</span>
tightfig();                                             <span class="comment">% compact figure</span>
<span class="keyword">for</span> i = 1:2; flushLegend(hleg(i),hax(i),<span class="string">'se'</span>); <span class="keyword">end</span>      <span class="comment">% flush legend</span>
</pre><img vspace="5" hspace="5" src="MainScript_01.png" alt=""> <h2>Plot 2: Radial temperature distribution at selected times<a name="13"></a></h2><pre class="codeinput"><span class="comment">% ------ Prepare ------ %</span>
s_plot = ekf;                  <span class="comment">% choose which model to use for contour plot</span>
<span class="keyword">for</span> ii = 1:length(tframes)
    ts = tframes(ii);

    <span class="comment">% SG</span>
    uu = s_plot.Psi'*s_plot.x(ts-1,:)';
    nfac = sqrt(size(s_plot.Psi,2));
    uu = reshape(uu,length(s_plot.rr)/nfac,length(s_plot.zz)/nfac);
    s_plot.Te = reshape(s_plot.Te,length(s_plot.rr)<span class="keyword">...</span>
        /nfac,length(s_plot.zz)/nfac);
    s_plot.ts.Tr = uu(round(size(uu,2)/2),:);
    s_plot.ts.Tr = s_plot.ts.Tr + s_plot.Te(round(size(s_plot.Te,2)/2),:);
    s_plot.ts.T = reshape(uu,length(s_plot.rr)/nfac,length(s_plot.zz)/nfac);
    s_plot.ts.T = s_plot.ts.T + reshape(s_plot.Te,length(s_plot.rr)<span class="keyword">...</span>
        /nfac,length(s_plot.zz)/nfac);

    <span class="comment">% Assign values to a structure containg multiple (3) tframes</span>
    mult(ii).sg = s_plot;
    mult(ii).ts = ts;

<span class="keyword">end</span>


<span class="comment">% ------ Plot ------ %</span>
figure(<span class="string">'position'</span>,[100 100 600 200])
<span class="keyword">for</span> i = 1:length(tframes)
    subplot(1,3,i); hold <span class="string">on</span>;
    plot(mult(i).sg.rr(1:nfac:end),mult(i).sg.ts.Tr);
    xlim([p.r1 p.r2]);
    xlabel(<span class="string">'r (m)'</span>);
    <span class="keyword">if</span> i == 1; ylabel(<span class="string">'Temperature (\circC)'</span>); <span class="keyword">end</span>
    title(sprintf(<span class="string">'\\it{t = %0.2i s}'</span>, mult(i).ts))
    set(gca,<span class="string">'fontsize'</span>,FS);
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="MainScript_02.png" alt=""> <h2>Plot 3: 2-D Temperature Contour Plot at selected time<a name="14"></a></h2><pre class="codeinput">figure(<span class="string">'position'</span>,[100 100 300 385]); hold <span class="string">on</span>;
contourf(s_plot.rr(1:nfac:end),s_plot.zz(1:nfac),mult(2).sg.ts.T,10);
contourf(-s_plot.rr(1:nfac:end),s_plot.zz(1:nfac),mult(2).sg.ts.T,10);
rectangle(<span class="string">'Position'</span>,[-p.r1 0 2*p.r1 p.z2],<span class="keyword">...</span>
    <span class="string">'facecolor'</span>,[.8 .8 .8],<span class="string">'edgecolor'</span>,<span class="string">'none'</span>)
str = sprintf(<span class="string">'\\it{t = %0.2i s}'</span>, mult(2).ts);
title(str,<span class="string">'fontweight'</span>,<span class="string">'n'</span>)
pbaspect([2.5*(p.r2-p.r1),p.z2,1])
set(gca,<span class="string">'xtick'</span>,[]); set(gca,<span class="string">'ytick'</span>,[]);
xlabel(<span class="string">'r'</span>); ylabel(<span class="string">'z'</span>);
colorbar
set(gca,<span class="string">'fontsize'</span>,FS)
</pre><img vspace="5" hspace="5" src="MainScript_03.png" alt=""> <h2>Error analysis 1: RMSE values<a name="15"></a></h2><pre class="codeinput"><span class="keyword">for</span> i = 1:3
    <span class="keyword">switch</span> i
        <span class="keyword">case</span> 1; s = sg;
        <span class="keyword">case</span> 2; s = ekf;
        <span class="keyword">case</span> 3; s = kf;
    <span class="keyword">end</span>
    sum_res(i) = sum((s.Tr1-exp.Tr1').^2) + sum((s.Tr2z1-exp.Tr2z1').^2)<span class="keyword">...</span>
        + sum((s.Tr2z2-exp.Tr2z2').^2) + sum((s.Tr2-exp.Tr2').^2);
<span class="keyword">end</span>
fprintf(<span class="string">'\nRMSE values:\n'</span>)
fprintf(<span class="string">'\nOL: %.1f\n'</span>, sum_res(1))
fprintf(<span class="string">'\nEKF: %.1f\n'</span>, sum_res(2))
fprintf(<span class="string">'\nKF: %.1f\n'</span>, sum_res(3))
sum_norm = [1, sum_res(2)/sum_res(1), sum_res(3)/sum_res(1)];
</pre><pre class="codeoutput">
RMSE values:

OL: 330642.2

EKF: 19553.6

KF: 3816.6
</pre><h2>Error analysis 2: Histogram of errors<a name="16"></a></h2><p>Calculate error data</p><pre class="codeinput">kf = func_hist_errors(kf, exp, xmax);
ekf = func_hist_errors(ekf, exp, xmax);

<span class="comment">% Plot</span>
figure(<span class="string">'position'</span>,[100 100 350 280])
h1 = histogram(kf.eTr1); hold <span class="string">on</span>;
h2 = histogram(ekf.eTr1);
xlim([-1.5 1.5])
xlabel(<span class="string">'Error (\circC)'</span>)
ylabel(<span class="string">'Number of points'</span>)
h1.BinWidth = .1; <span class="comment">% uniform bin width</span>
h2.BinWidth = .1;

<span class="comment">% Text</span>
<span class="keyword">for</span> i = 1:2
    <span class="keyword">if</span> i == 1; rmsi = ekf.rmsr1; <span class="keyword">else</span> rmsi = kf.rmsr1; <span class="keyword">end</span>
    rms_str = sprintf(<span class="keyword">...</span>
        <span class="string">'$|\\overline{\\varepsilon}_{EKF}| = %.1f ^\\circ C $'</span>,rmsi);
    text(-1.35,275+50*i,rms_str,pl.fs,FS,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
<span class="keyword">end</span>
hleg = legend([h1,h2],<span class="string">'KF with T_3'</span>,<span class="string">'EKF with Z'''''</span>);
flushLegend(hleg);
</pre><img vspace="5" hspace="5" src="MainScript_04.png" alt=""> <p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2015b</a><br></p></div><!--
##### SOURCE BEGIN #####
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-%
%              2-D EKF Impedance-Temperature State-Estimator              %
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-%

%{
My name is Robert Richardson (robert.richardson@eng.ox.ac.uk) and I hold 
the MIT license for this code. An accompanying paper for this code is:
% Robert R. Richardson, Shi Zhao, David A. Howey, On-board monitoring of
% 2-D spatially-resolved temperatures in cylindrical lithium-ion batteries:
% Part I. Low-order thermal modelling, Journal of Power Sources, Vol 326,
% 2016, Pages 377-388, http://dx.doi.org/10.1016/j.jpowsour.2016.06.103.

I would ask that you cite this paper if you want to use this code for 
your own research. For further details on the work of the Energy Power 
Group at Oxford, please see epg.eng.ox.ac.uk.
%}

% This code implements a Chebyshev Spectral Galerkin 2D thermal model and
% an Extended Kalman Filter using electrochemical impedance measurement
% input.

% Guide to structures used:
% 'p':          stores [p]arameters and inputs (common to both models)
% 'sg':         stores [s]pectral-[G]alerkin model inputs/outputs
% 'kf':         stores [K]alman [f]iltered model inputs/outputs
% 'ekf':        stores [E]xtended [K]alman [f]iltered model inputs/outputs
% 'mult':       stores outputs at [mult]iple instances (for both models)


%% Initialise
clear; close all; clc;
addpath(genpath('./Functions'));
addpath(genpath('./Data'));
pl = abbreviations();   % struct of abbreviations for commonly used strings
set(0,'defaultaxeslinewidth',1.0)                    % plotting preferences
set(0,'defaultlinelinewidth',1.4)
FS = 10;   % fontsize


%% Options
% Below are some options for the user to play around with.

sel_exp = 4;             % select exp. (1,2)=uninsulated; (3,4)=insulated
sel_eis = 4;             % select EIS fit (4=HEV-II; ensures only interp.)
sel_error = true;     	 % initialise with error? (otherwise plots EIS fit)
sel_thermocouple = 3;  	 % select thermocouple measurement for linear KF
                      	 % T_1 (core), T_2 (surf left), T_3 (surf mid),
                         % T_4 (surf right).
plot_times = [150,800];  % choose times (sec) at which to plot radial dist.
                        

%% Assign options
exp_info = cell(1,2);
switch sel_exp                                           % drive cycle info
    case {2,3,4}; exp_info{1} = 'HEV-I';
    case {1}; exp_info{1} = 'HEV-II';
end
switch sel_exp                       % configuration: insulated/uninsulated
    case {1,2}; exp_info{2} = 'Uninsulated';
    case {3,4}; exp_info{2} = 'Insulated';
end
str_info = strcat(exp_info{1},' (', exp_info{2},')');


%% Experimental data
% Load experimental data, struct 'exp', containing current, voltage,
% temperatures and impedance.
switch sel_exp
    case 1; load('Data_Uninsulated_1');
    case 2; load('Data_Uninsulated_2');
    case 3; load('Data_Insulated_1');
    case 4; load('Data_Insulated_2');
end
exp.Tz1 = -ones(size(exp.t));           % no measurements at right centre
exp.Tz2 = -ones(size(exp.t));           % no measurements at left centre


%% Parameters and Inputs
p = func_parameters();   	  % assign struct 'p' of known model parameters
p = func_inputs_exp(p,exp);   % assign model inputs to 'p'


%% Assign identified parameters
% Assign parameters, k_z, h_r, h_l, h_t and h_b, from parameter
% identification experiments.

% Use identified parameters from either experiment for each configuration.
% Loaded data consists of struct 'id' containing fields of parameters.
switch sel_exp
    case {1,2}; load('Identified_Parameters_Uninsulated_2');         % or 1
    case {3,4}; load('Identified_Parameters_Insulated_2');           % or 1
end

% Assign identified parameters to struct 'p'
p.kz = id.kz;                       % axial thermal conductivity
p.hr = id.hr; p.hl = 0;             % left/right convection coefficient
p.hb = id.hb; p.ht = id.ht;         % top/bottom convection coefficient

% Display parameters
fprintf(char(strcat(...
    'Parameters from',{' '},exp_info{2}, ' configuration.\n')));
fprintf('cp\t\t kr\t\t kz\n%.0f \t %.3f \t %.2f \n', p.cp,p.kr,p.kz)
fprintf('hr\t\t hb\t\t ht\n%.1f \t %.1f \t %.1f \n\n',...
    p.hr,p.hb,p.ht)



%% Load EIS polyfits
% Load EIS data. Data consists of struct 'pol' containing the polyfit of
% impedance-temperature data.
switch sel_eis
    case 1; load('Identified_EIS_Uninsulated_1','pol');
    case 2; load('Identified_EIS_Uninsulated_2','pol');
    case 3; load('Identified_EIS_Insulated_1','pol');
    case 4; load('Identified_EIS_Insulated_2','pol');
end
% load('./Data/Identified_EIS','pol');


%% Spectral-galerkin model
sg.N = 2;                        % no. of basis functions in each direction
sg.Ns = sg.N^2;                                       % total no. of states
[sg.A,sg.B,sg.C,sg.E,sg.rr,sg.zz,sg.Psi,sg.Te,sg.ye] = ...
    func_spectral_galerkin(p, sg.N);          	 % calculate state matrices

% Prepare simulation
sg.t_step = 1;
sg.A_d = expm((sg.E\sg.A)*sg.t_step);
sg.B_d = (sg.E\sg.A)\((sg.A_d-eye(size(sg.A_d)))*(sg.E\sg.B));

% Initialise states, inputs and outputs
sg.x = zeros(length(p.t),length(sg.A));                            % states
switch sel_error                             % initialise with error or not
    case 0; sg.x(1,:) = [7.3464 -0.0253 -0.0614 -0.3167];  	% correct inits
    case 1; sg.x(1,:) = [22.2855 1.98354 4.56853 0.305134];    % with error
end
sg.u = zeros(size(sg.B,2),length(p.t));                            % inputs
sg.y = zeros(length(p.t),size(sg.C,1));                           % outputs



%% Simulate
% Initialise models
ol = sg;                         % open-loop model (copy spectral galerkin)
kf = func_init_kf(sg, 5e-3, 0.3, 1);                 % linear kalman filter
ekf = func_init_kf(sg, 5e-3, 3e-5, 1); 	  % extended kalman filter (with Z)
sel_meas = ...     % assign selected thermocouple measurement for linear KF
    func_thermocouple2measurement(sel_thermocouple);

% Loop over time steps
for i = 1:length(p.t)-1
    ui = [p.Q(i)/p.Vb; 1];                                        % input i
    meas_vec = [-1,-1,exp.Tr1(i),exp.Tr2(i),...
        exp.Tr2z2(i), exp.Tr2z1(i)];      % vector of all measurements at i
    sg = func_predict(sg,i,ui);                         % open-loop predict
    kf = func_predict(kf,i,ui);                                % KF predict
    kf = func_measure(kf,i,meas_vec,sel_meas);                 % KF measure
    ekf = func_predict(ekf,i,ui);                             % EKF predict
    Zm = exp.Im(i);
    if Zm~=-1; ekf = func_measure_nl(ekf,i,Zm,pol.p); end     % EKF measure
end

% Rename outputs as something more intuitive
sg = func_rename_outputs(sg);
kf = func_rename_outputs(kf);
ekf = func_rename_outputs(ekf);
ekf.Im = ekf.Zp;


%% Plot 0: Polyfit of impedance

plot_eis = ~sel_error;    % plot EIS fit (if running with no initial error)
if plot_eis == 1;
    pol.T = sg.Tm(exp.tm)';
    pol.Z = exp.Im(exp.tm);
    ids = [];
    for i = 2:length(pol.T)                  % enforce monotonic increasing
        if pol.T(i)<pol.T(i-1); ids = [ids,i]; end
    end
    pol.T = pol.T(ids); pol.Z = pol.Z(ids);
    pol.Tnew = min(pol.T):0.1:max(pol.T);
    pol.Znew = interp1(pol.T,pol.Z,pol.Tnew);
    pol.T = pol.Tnew; pol.Z = pol.Znew;

    % Polyfit
    pol.p = polyfit(pol.T,pol.Z,2);
    pol.Tcont = linspace(min(pol.T)-1, max(pol.T)+1);
    pol.Zcont = polyval(pol.p,pol.Tcont);

    % Plot
    figure('position',[700 100 400 300]); hold on;
    plot(pol.T,pol.Z,'o','markersize',5,'color',pl.b)
    plot(pol.Tcont,pol.Zcont,'linewidth',1.6,'color',pl.r)
    xlim([pol.Tcont(1),pol.Tcont(end)])
    xlabel('Temperature (\circ C)')
    ylabel('Im(Z) (\Omega)')
    legend('Data','Polynomial fit')
    tightfig();
end


%% Plot 1: Measured vs predicted temperatures
% (a) Temperature profiles: T(top, centre) and T(bottom, centre) vs. time
% (b) Heat generation profile: Q vs. t
figure('position',[100 100 700 420])

% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH- Plot (a): Temperature Evolution REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH- %
hax(1) = subplot(4,1,1:3); hold on;
ha = plot(exp.t,exp.Tenv, 'k-', 'linewidth',1);                       % air

% Experimental
hEXP = plot(exp.t,exp.Tr1,'-','color',[.3 .3 .3],'markersize',5);
plot(exp.t,exp.Tr2z2,'-','color',[.3 .3 .3],'markersize',5);
plot(exp.t,exp.Tr2,'-','color',[.3 .3 .3],'markersize',5);

% Open-loop
hSG = plot(p.t,sg.Tr1,'color',pl.b);
plot(p.t,sg.Tr2, 'color',pl.b);
plot(p.t,sg.Tr2z2, 'color',pl.b);

% Kalman Filter (with T_3)
plot(p.t,kf.Tr2z2,     'color',pl.g,'linestyle','REPLACE_WITH_DASH_DASH');
plot(p.t,kf.Tr2,     'color',pl.g,'linestyle','REPLACE_WITH_DASH_DASH');
hKF1 = plot(p.t,kf.Tr1,     'color',pl.g,'linestyle','REPLACE_WITH_DASH_DASH');
% plot(p.t,f1.Tm,'color',fl.g,'linestyle','REPLACE_WITH_DASH_DASH');                     % mean

% Extended Kalman Filter (with Z)
plot(p.t,ekf.Tr2z2,'color',pl.r,'linestyle','-.');  
plot(p.t,ekf.Tr2,'color',pl.r,'linestyle','-.');  
hKF_nl = plot(p.t,ekf.Tr1,'color',pl.r,'linestyle','-.');

% Axis limits/labels/legend
xmax = 2600;
xlim([0 xmax]);
ylims = get(gca,'ylim');
set(gca,'xticklabel',[]);
ylabel('Temperature (\circC)');
set(gca,'fontsize',FS);
hleg(1) = legend([hEXP hSG hKF1 hKF_nl ha],...
    'Experimental','Open-loop','KF with T_s','EKF with Z''''','Air',...
    'location','best');

% Plot tframes line
tframes = [plot_times,xmax];
plot([tframes(1), tframes(1)],[ylims(1), ylims(2)],'k-.','linewidth',1)
text(xmax*0.03,ylims(2)*0.98,str_info,...
    'fontsize',FS,'verticalalignment','top','horizontalalignment','left')


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH- Plot (b): Impedance Profile REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH- %
hax(2) = subplot(4,1,4); hold on;
plot(exp.tm, 1e3*exp.Im(exp.tm),'-','color',[.3 .3 .3]);
plot(exp.tm, 1e3*ekf.Im(exp.tm),'-.');
xlim([0 xmax]);
ylabel('Z'''' (m\Omega)');
xlabel('Time (s)');
hleg(2) = legend('Experimental','EKF with Z''''');
set(gca,'fontsize',FS)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH Post-process REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH %
linkaxes([hax(1), hax(2)],'x');                         % link axes
tightfig();                                             % compact figure
for i = 1:2; flushLegend(hleg(i),hax(i),'se'); end      % flush legend


%% Plot 2: Radial temperature distribution at selected times

% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH Prepare REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH %
s_plot = ekf;                  % choose which model to use for contour plot
for ii = 1:length(tframes)
    ts = tframes(ii);

    % SG
    uu = s_plot.Psi'*s_plot.x(ts-1,:)';
    nfac = sqrt(size(s_plot.Psi,2));
    uu = reshape(uu,length(s_plot.rr)/nfac,length(s_plot.zz)/nfac);
    s_plot.Te = reshape(s_plot.Te,length(s_plot.rr)...
        /nfac,length(s_plot.zz)/nfac);
    s_plot.ts.Tr = uu(round(size(uu,2)/2),:);
    s_plot.ts.Tr = s_plot.ts.Tr + s_plot.Te(round(size(s_plot.Te,2)/2),:);
    s_plot.ts.T = reshape(uu,length(s_plot.rr)/nfac,length(s_plot.zz)/nfac);
    s_plot.ts.T = s_plot.ts.T + reshape(s_plot.Te,length(s_plot.rr)...
        /nfac,length(s_plot.zz)/nfac);
    
    % Assign values to a structure containg multiple (3) tframes
    mult(ii).sg = s_plot;
    mult(ii).ts = ts;

end


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH Plot REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH %
figure('position',[100 100 600 200])
for i = 1:length(tframes)
    subplot(1,3,i); hold on;
    plot(mult(i).sg.rr(1:nfac:end),mult(i).sg.ts.Tr);
    xlim([p.r1 p.r2]);
    xlabel('r (m)');
    if i == 1; ylabel('Temperature (\circC)'); end
    title(sprintf('\\it{t = %0.2i s}', mult(i).ts))
    set(gca,'fontsize',FS);
end


%% Plot 3: 2-D Temperature Contour Plot at selected time

figure('position',[100 100 300 385]); hold on;
contourf(s_plot.rr(1:nfac:end),s_plot.zz(1:nfac),mult(2).sg.ts.T,10);
contourf(-s_plot.rr(1:nfac:end),s_plot.zz(1:nfac),mult(2).sg.ts.T,10);
rectangle('Position',[-p.r1 0 2*p.r1 p.z2],...
    'facecolor',[.8 .8 .8],'edgecolor','none')
str = sprintf('\\it{t = %0.2i s}', mult(2).ts);
title(str,'fontweight','n')
pbaspect([2.5*(p.r2-p.r1),p.z2,1])
set(gca,'xtick',[]); set(gca,'ytick',[]);
xlabel('r'); ylabel('z');
colorbar
set(gca,'fontsize',FS)


%% Error analysis 1: RMSE values
for i = 1:3
    switch i
        case 1; s = sg; 
        case 2; s = ekf;
        case 3; s = kf;
    end
    sum_res(i) = sum((s.Tr1-exp.Tr1').^2) + sum((s.Tr2z1-exp.Tr2z1').^2)...
        + sum((s.Tr2z2-exp.Tr2z2').^2) + sum((s.Tr2-exp.Tr2').^2);
end
fprintf('\nRMSE values:\n')
fprintf('\nOL: %.1f\n', sum_res(1))
fprintf('\nEKF: %.1f\n', sum_res(2))
fprintf('\nKF: %.1f\n', sum_res(3))
sum_norm = [1, sum_res(2)/sum_res(1), sum_res(3)/sum_res(1)];

%% Error analysis 2: Histogram of errors
% Calculate error data
kf = func_hist_errors(kf, exp, xmax);
ekf = func_hist_errors(ekf, exp, xmax);

% Plot
figure('position',[100 100 350 280])
h1 = histogram(kf.eTr1); hold on;
h2 = histogram(ekf.eTr1);
xlim([-1.5 1.5])
xlabel('Error (\circC)')
ylabel('Number of points')
h1.BinWidth = .1; % uniform bin width
h2.BinWidth = .1;

% Text
for i = 1:2
    if i == 1; rmsi = ekf.rmsr1; else rmsi = kf.rmsr1; end
    rms_str = sprintf(...
        '$|\\overline{\\varepsilon}_{EKF}| = %.1f ^\\circ C $',rmsi);
    text(-1.35,275+50*i,rms_str,pl.fs,FS,'interpreter','latex')
end
hleg = legend([h1,h2],'KF with T_3','EKF with Z''''');
flushLegend(hleg);







##### SOURCE END #####
--></body></html>